---
title: 'Notes de le√ßon | Structures de donn√©es'
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true 
    css: !expr here::here("global/style/style.css")
    highlight: kate
editor_options:
  markdown:
    wrap: 100
  canonical: true
  chunk_output_type: console
---

```{r, include = FALSE, warning = FALSE, message = FALSE}
# Charger les packages
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, knitr, here)

# Charger les fonctions
source(here("global/functions/misc_functions.R"))

# Param√®tres knitr
knitr::opts_chunk$set(warning = F, message = F, class.source = "tgc-code-block", error = T)
```

# Intro

Dans cette le√ßon, nous allons jeter un coup d'≈ìil aux structures de donn√©es en R. Comprendre les structures de donn√©es est crucial pour la manipulation et l'analyse des donn√©es. Nous commencerons par explorer les vecteurs, la structure de donn√©es de base dans R. Ensuite, nous apprendrons √† combiner des vecteurs dans des data frames, la structure la plus courante pour organiser et analyser des donn√©es.

# Objectifs d'apprentissage

1. Vous pouvez cr√©er des vecteurs avec la fonction `c()`.

2. Vous pouvez combiner des vecteurs dans des data frames. 

3. Vous comprenez la diff√©rence entre un tibble et un data frame.

# Packages

Veuillez charger les packages n√©cessaires pour cette le√ßon avec le code ci-dessous :

```{r}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse)
```

# Introduction aux vecteurs

Les structures de donn√©es les plus √©l√©mentaires dans R sont les vecteurs. Les vecteurs sont une collection de valeurs qui partagent toutes la m√™me classe (par exemple, toutes num√©riques ou toutes caract√®res). Il peut √™tre utile de penser √† un vecteur comme une colonne dans une feuille de calcul Excel.

# Cr√©ation de vecteurs

Les vecteurs peuvent √™tre cr√©√©s en utilisant la fonction `c()`, avec les composantes du vecteur s√©par√©es par des virgules. Par exemple, le code `c(1, 2, 3)` d√©finit un vecteur avec les √©l√©ments `1`, `2` et `3`.

Dans votre script, d√©finissez les vecteurs suivants :

```{r}
age <- c(18, 25, 46)
sexe <- c('M', 'F', 'F') 
test_positif <- c(V, V, F)
id <- 1:3 # le deux points cr√©e une s√©quence de nombres
```

Vous pouvez √©galement v√©rifier les classes de ces vecteurs :

```{r}
class(age)
class(sexe)
class(test_positif)
```

::: r-practice
Chaque ligne de code ci-dessous tente de d√©finir un vecteur avec trois √©l√©ments mais contient une erreur. Corrigez les erreurs et effectuez l'affectation.

```{r eval = FALSE}
my_vec_1 <- (1,2,3)
my_vec_2 <- c("Obi", "Chika" "Nonso")
```
:::

::: vocab
Les valeurs individuelles au sein d'un vecteur sont appel√©es *composantes* ou √©l√©ments. Donc le vecteur `c(1, 2, 3)` a trois composantes/√©l√©ments.
:::

# Manipulation de vecteurs

De nombreuses fonctions et op√©rations que vous avez d√©j√† rencontr√©es dans le cours peuvent √™tre appliqu√©es √† des vecteurs.

Par exemple, nous pouvons multiplier notre objet `age` par 2 :

```{r}
age
age * 2
```

Remarquez que chaque √©l√©ment du vecteur a √©t√© multipli√© par 2.

Ou, ci-dessous nous prenons la racine carr√©e de `age` :

```{r}
age
sqrt(age)
```

------------------------------------------------------------------------

Vous pouvez √©galement additionner (num√©riquement) des vecteurs :

```{r}
age + id
```

Remarquez que le premier √©l√©ment de `age` est ajout√© au premier √©l√©ment de `id` et le deuxi√®me √©l√©ment de `age` est ajout√© au deuxi√®me √©l√©ment de `id`, et ainsi de suite.

------------------------------------------------------------------------

# Des vecteurs aux data frames

Maintenant que nous ma√Ætrisons la cr√©ation de vecteurs, passons √† l'objet le plus couramment utilis√© dans R : les data frames. Un data frame est juste une collection de vecteurs de m√™me longueur avec des m√©tadonn√©es utiles. Nous pouvons en cr√©er un en utilisant la fonction `data.frame()`.

Nous avons pr√©c√©demment cr√©√© des variables de type vecteur (id, age, sexe et test_positif) pour trois individus :

Nous pouvons maintenant utiliser la fonction `data.frame()` pour les combiner dans une seule structure tabulaire :

```{r}
donnees_epi <- data.frame(id, age, sexe, test_positif)
donnees_epi
```

Remarquez qu'au lieu de cr√©er chaque vecteur s√©par√©ment, vous pouvez cr√©er votre data frame en d√©finissant chacun des vecteurs √† l'int√©rieur de la fonction `data.frame()`.

```{r}
donnees_epi_2 <- data.frame(age = c(18, 25, 46), 
                           sexe = c('M', 'F', 'F'))

donnees_epi_2
```


::: side-note
La plupart du temps lorsque vous travaillez avec des donn√©es dans R, vous les importerez de contextes externes. Mais il est parfois utile de cr√©er des jeux de donn√©es *dans* R lui-m√™me. C'est dans de tels cas que la fonction `data.frame()` sera utile.
:::

Pour extraire les vecteurs du data frame, utilisez la syntaxe `$`. Ex√©cutez les lignes de code suivantes dans votre console pour observer ceci.

```{r eval = FALSE}
donnees_epi$age
is.vector(donnees_epi$age) # v√©rifie que cette colonne est bien un vecteur
class(donnees_epi$age) # v√©rifie la classe du vecteur
```

::: r-practice
Combinez les vecteurs ci-dessous dans un data frame, avec les noms de colonnes suivants : "name" pour le vecteur de caract√®res, "number_of_children" pour le vecteur num√©rique et "is_married" pour le vecteur logique.

```{r}
vecteur_caracteres <- c("Bob", "Jane", "Joe")
vecteur_numerique <- c(1, 2, 3)
vecteur_logique <- c(V, F, F)
```
:::

::: r-practice
Utilisez la fonction `data.frame()` pour d√©finir dans R un data frame qui ressemble au tableau suivant :

 | salle      | nb_fenetres |
 |------------|-------------|
 | salle √† manger | 3          |
 | cuisine     | 2          |
 | chambre     | 5          |
:::

# Tibbles

La version par d√©faut des donn√©es tabulaires dans R s'appelle un data frame, mais il existe une autre repr√©sentation des donn√©es tabulaires fournie par le package *tidyverse*. Elle s'appelle un `tibble`, et c'est une version am√©lior√©e du data frame.

Vous pouvez convertir un data frame en tibble avec la fonction `as_tibble()` :

```{r}
donnees_epi
tibble_epi <- as_tibble(donnees_epi)
tibble_epi
```

Remarquez que le tibble donne les dimensions des donn√©es dans la premi√®re ligne :

```
üëâ# A tibble: 3 √ó 4üëà
     id   age sexe   test_positif
  <int> <dbl> <chr> <lgl>
1     1    18 M     TRUE
2     2    25 F     TRUE  
3     3    46 F     FALSE
```

Et indique √©galement les types de donn√©es, en haut de chaque colonne : 

```
# A tibble: 3 √ó 4
     id   age sexe   test_positif
üëâ  <int> <dbl> <chr> <lgl> üëà
1     1    18 M     TRUE
2     2    25 F     TRUE
3     3    46 F     FALSE
```

Ici, "int" signifie entier, "dbl" signifie double (un type num√©rique), "chr" signifie caract√®re et "lgl" signifie logique.

------------------------------------------------------------------------

L'autre avantage des tibbles est qu'ils √©vitent d'inonder votre console lorsque vous imprimez un grand tableau.

Consid√©rez par exemple la sortie console des lignes ci-dessous :

```{r eval = F}
# imprime le data frame infert (un jeu de donn√©es R int√©gr√©) 
infert # Impression tr√®s longue
as_tibble(infert) # impression plus g√©rable
```

Pour la plupart de vos besoins d'analyse de donn√©es, vous devriez pr√©f√©rer les tibbles aux data frames classiques.


## `read_csv()` cr√©e des tibbles

Lorsque vous importez des donn√©es avec la fonction `read_csv()` de {readr}, vous obtenez un tibble :

```{r}
ebola_tib <- read_csv("https://tinyurl.com/ebola-data-sample") # N√©cessite internet
class(ebola_tib)
```

Mais lorsque vous importez des donn√©es avec la fonction `read.csv()` de base, vous obtenez un data.frame :

```{r}
ebola_df <- read.csv("https://tinyurl.com/ebola-data-sample") # N√©cessite internet
class(ebola_df)
```

Essayez d'imprimer `ebola_tib` et `ebola_df` dans votre console pour observer le comportement d'impression diff√©rent des tibbles et des data frames.

C'est une des raisons pour lesquelles nous recommandons d'utiliser `read_csv()` plut√¥t que `read.csv()`.

# Conclusion

Avec votre compr√©hension des classes et des structures de donn√©es, vous √™tes d√©sormais bien √©quip√© pour effectuer des t√¢ches de manipulation de donn√©es dans R. Dans les prochaines le√ßons, nous explorerons les puissantes capacit√©s de transformation de donn√©es du package dplyr, qui am√©lioreront encore vos comp√©tences en analyse de donn√©es.

F√©licitations d'√™tre arriv√© jusque-l√† ! Vous avez couvert beaucoup de choses et vous pouvez √™tre fier de vous.

# Solutions

Solution au premier bloc r-practice :

```{r}
my_vec_1 <- c(1,2,3) # Utilisez la fonction 'c' pour cr√©er un vecteur
my_vec_2 <- c("Obi", "Chika", "Nonso") # S√©parez chaque cha√Æne par une virgule
```

Solution au deuxi√®me bloc r-practice :

```{r}
df <- data.frame(name = vecteur_caracteres,
                 number_of_children = vecteur_numerique,
                 is_married = vecteur_logique)
```

Solution au troisi√®me bloc r-practice :

```{r}
# Solution au troisi√®me bloc r-practice
pieces <- data.frame(piece = c("salle √† manger", "cuisine", "chambre"),
                     nb_fenetres = c(3, 2, 5))

```


## Contributeurs {.unlisted .unnumbered}

L'√©quipe suivante a contribu√© √† cette le√ßon : `r tgc_contributors_list(ids = c("dcpcamara", "eduardo", "lolovanco", "kendavidn"))`

<!-- Seuls les membres de l'√©quipe ayant contribu√© "substantiellement" √† une le√ßon sp√©cifique doivent √™tre list√©s ici -->

<!-- Voir https://tinyurl.com/icjme-authorship pour les notes sur la contribution "substantielle"-->

## R√©f√©rences {.unlisted .unnumbered}

Certains √©l√©ments de cette le√ßon ont √©t√© adapt√©s des sources suivantes :

- Wickham, H., & Grolemund, G. (s.d.). *R for data science*. 15 Factors | R for Data Science. Consult√© le 26 octobre 2022. https://r4ds.had.co.nz/factors.html.

<!-- (format Chicago. Vous pouvez utiliser https://www.citationmachine.net) -->

`r tgc_license()`
